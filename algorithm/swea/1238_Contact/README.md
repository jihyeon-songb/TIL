## 1238_Contact

비상연락망과 연락을 시작하는 당번에 대한 정보가 주어질 때, 가장 나중에 연락을 받게 되는 사람 중 번호가 가장 큰 사람을 구하는 함수를 작성하시오.

**[제약 사힝]**

연락 인원은 최대 100명, 부여될 수 있는 번호 1이상, 100이하이다.

중간에 비어있는 번호가 있을 수 있다. 연락 받지 못한 사람도 존재할 수 있다.

**[입력]**

입력의 첫 번째 줄에는 입력받는 데이터의 길이외 시작점이 주어진다.

그 다음 줄에 입력받는 데이터는 [from, to, from, to, ...]의 순서로 해석된다.



#### ✔ 코드 풀이

가장 나중에 연락받는 사람 중 번호가 가장 큰 사람을 구해야한다.

깊이로 탐색하면 나중에 연락받는 사람을 찾지 못하므로 너비 우선 탐색을 이용해야한다.

인접 리스트를 이용해 어떻게 연결되어 있는지 입력한다.

만약 1 -> 17 이면 arr[1] 리스트에 17이 들어가게 한다. 

```python
# 0~100번의 인덱스를 가진 빈 배열 생성
arr = [[0] for _ in range(101)]
# from인덱스에 to의 값을 넣어준다
for i in range(0,len(from_to),2):
    arr[from_to[i]].append(from_to[i+1])
```

너비 우선 탐색을 하기 위해 deque를 이용하자

dq라는 deque를 만들어주고 시작점과 첫번째로 방문했다는 것을 넣어주었다.

visited에도 방문했음을 넣어주었다. 

⭐ 근데 여기서 다시 생각해보니 visited에 방문횟수를 넣어줬기 때문에 다시 deque에 방문횟수를 넣어	  줄 필요가 없어 다시 고쳤다..

😁 visited에 안 넣어줬다면 deque에 넣어서 사용하면 된다.

```python
dq = deque()
# 처음에 시작점과 첫번째로 방문함을 넣어줌
dq.append(start)
# 0~100번을 방문했는지 체크해 줄 리스트
visited = [0] * 101
# 시작점에 1번째로 방문했음을 넣어준다.
visited[start] = 1 
```

start가 연락할 수 있는 번호부터 dq에 넣어주고 방문횟수를 1씩 늘려준다.

```python
while dq:
    x = dq.popleft()
    # x번이 연락할 수 있는 모든 번호 순회
    for i in range(1,len(arr[x])):
        nx = arr[x][i]
        # 방문하지않았던 번호들만 방문하고 몇번째로 방문했는지 저장
        if visited[nx] == 0:
            visited[nx] = visited[x] + 1
            dq.append(nx)
```

마지막으로 방문한 번호들은 visited이 제일 큰 값을 가진 인덱스이므로 그 인덱스들을 찾고 

값이 큰 인덱스 중에서도 인덱스가 큰 값을 찾아야 하는데 값이 같아도 

인덱스는 큰 값으로 바뀔 수 있게 <=을사용한다.

```python
last = 0
last_max = 0
for i in range(101):
    if visited[i] > 0:
        if last <= visited[i]:
            last_max = i
            last = visited[i]
```

그리고 출력하면 끝!~



😊 BFS를 연습할 수 있는 좋은 문제였다. BFS 푸는건 역시 재미있다!