### 1493_수의 새로운 연산

![](C:\Users\msi\Desktop\캡처 코드\1493.PNG)

2차원 평면 제 1사분면 위의 격자점 (x,y)에 위 그림과 같이 대각선 순서로 점에 수를 붙인다.

점 (x,y)에 할당된 수는 #(x,y)로 나타낸다.

반대로 수 p가 할당된 점은 &(p)로 나타낸다.

두 점에 대해 덧셈을 정의하는데, 점 (x,y)와 점 (z,w)를 더하면 점 (x+y,y+w)가 된다.

문제는 새로운 연산 ⭐을 구현해야하는 것으로 p⭐q는 #(&(p)+&(q))으로 나타난다.

예를 들어 &(1) = (1,1), &5 = (2,2)이면 1⭐5는 #(&(1)+&(5)) = #((1,1)+(2,2)) = #(3,3) = 13이 된다.



**[입력]**

첫 번째 줄에 테스트 케이스 T가 주어지고

각 테스트 케이스이 첫 번째 줄에는 두 정수 p,q(1<=p,q<=10000)가 주어진다.



### ✔ 코드 풀이

처음에는 대각선 순서로 수를 붙인 배열을 100*100을 잡았다.

근데 자꾸만.. index에러가 났다. 

p와 q가 커도 10000이여서 100정도면 괜찮다고 생각했는데

p와 q가 연산을 하면 더 커지기 때문에 100*100은 아주 부족했던 것이었다.

그게 아니더라도 출력해보니 (100, 1)이 5000정도의 값을 가지기 때문에 아주 부족한 것을 알았다.

그래서 300*300으로 배열을 만들었다. 

```python
arr = [[0]*300 for _ in range(300)]

value = 1
xy = 1

while True:
    for j in range(xy,0,-1):
        temp = (xy+1) - j
        arr[j][temp] = value
        value += 1
    xy += 1

    if xy == 300:
        break
```

테스트 케이스 돌리기 전에 이미 값이 든 300*300 배열을 만들어 놓았다. 

인덱스를 어떻게 넣어줘야 되는 지도 고민을 많이 했는데

만약 내가 넣어야하는 그 구간이 (3,1) (2,2) (1,3) 이면 x와 y값의 합이 다 같다는 것에서 생각할 수 있었다.

```python
for tc in range(1,T+1):
    p, q = map(int, input().split())

    x = 0
    y = 0
    count = 0

    while True:
        for i in range(1,300):
            for j in range(1,300):
                if arr[i][j] == p or arr[i][j] == q:
                    x += i
                    y += j
                    count += 1
                if count == 2:
                    break
                
        if count == 2:
            break

    result = arr[x][y]
```

테스트 케이스를 돌려준 구간이다.

열심히 돌려서 p와 q가 있는 x,y값을 더해주고 p와 q를 다 찾았다는 것을 count가 2가 되면 알 수 있고

count가 2가 되면 반복문을 모두 탈출했다.

그리고 더해준 x,y인덱스의 값을 결과에 저장해주면 답이 나온다. 



🤔 흠 그런데 시간이 많이 걸려서(580ms) 더 효율적인 방법이 있는지 또 생각해봐야할 것 같다ㅠㅠ 

