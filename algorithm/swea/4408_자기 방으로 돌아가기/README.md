## 4408_자기 방으로 돌아가기

![](C:\Users\msi\Desktop\캡처 코드\4408.PNG)

숙소는 긴 복도를 따라 총 400개의 방이 다음과 같이 배열되어 있다.

학생들은 음주가무를 즐기다가 밤 12시가 되자 조교들의 눈을 피해 자기방으로 돌아가려고 한다.

자기방으로 돌아가려고 하는데 복도의 구간이 겹치면 두 학생은 동시에 돌아갈 수 없다.

복도 구간이 겹치면 한 사람은 기다렸다가 다음 차례에 이동해야 한다. 

이동하는 데에는 거리와 관계없이 단위 시간이 걸린다.

최소 몇 단위시간만에 모든 학생들이 이동할 수 있을까.

**[입력]**

입력은 T(<=10)개의 테스트 케이스로 되어 있다.

테스트 케이스 첫 줄에는 돌아가야 할 학생들의 수 N이 주어진다.

다음 N줄에는 각 학생의 현재 방 번호(<=400)와 돌아가야 할 방 번호(<=400)이 주어진다.



### ✔ 코드 풀이

겹치는 구간을 카운팅하고 카운팅한 개수 중에 최댓값을 구하려고 했다.

만약 5명 중 3명이 겹치는 구간이 있다면 그 구간은 카운팅이 3번 될 것이다.

3명을 결국 따로 가야하기 때문에 3단위시간이 걸리고 이것은 구간이 카운팅된 값과 같다.

```python
for tc in range(1,T+1):
    N = int(input())
    arr = [0] * 401

    for i in range(N):
        now ,later = map(int,input().split())
        if now > later:
            now, later = later, now

        if now % 2 == 0:
            now -= 1
        if later % 2:
            later += 1

        for j in range(now,later+1):
            arr[j] += 1
```

그래서 일단 카운팅할 값을 넣어줄 401개의 0으로 된 1차원 배열을 만들었다.

처음에는 생각을 못해주었는데 현재 위치 방 번호보다 돌아갈 방의 번호가 더 작을 수도 있다.

다음의 홀수, 짝수를 더해주는 코드에 맞게 해주려면 

현재 위치 방 번호보다 돌아갈 방의 번호가 더 작을때 그 둘의 번호를 바꾸어준다.

복도가 (홀수, 짝수)로 되어있는데 더 큰 수가 짝수이기 때문에 ex (1, 2)

현재 위치 방 번호가 짝수라면 1 작은 홀수와의 복도와 같은 구간이기때문에

그 구간도 카운팅을 해주려면 1를 빼줘야한다.

돌아갈 방 번호가 홀수라면 1 큰 짝수와의 복도와 같은 구간이어서 1을 더해준다.

그래서 만들어준 now, later까지의 인덱스의 값에 1을 더해준다.

```python
    max_value = 0

    for i in range(401):
        if max_value < arr[i]:
            max_value = arr[i]
```

카운팅한 배열을 순회하여 그 중 가장 크게 카운팅이 된 값을 찾아주면 답이 나온다!



😁 굉장히 재미있는 문제였다. 다른 방식으로도 풀어보고 싶다!

